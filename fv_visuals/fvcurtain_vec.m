% /////// fvcurtain_vec ///////
% C = fvcurtain_vec(C)
% Create / update the velocity vectors tangential to the patch faces on an existing fvcurtain plot.
% Vectors are plotted at the centre of the patch faces in the curtain plot
% If the vertical velocity component 'W' was not output for a 3D sim then a warning
% is displayed.
%
% inputs
%   C = stucture generated by fvcurtain
%       various options eg. v_multi, v_color are optioal fields in C which
%       if not included are set to defaults
%
% outputs
%   C = structure with additional fields
%       if fvcurtain was used to visualise variables other than
% Jesper Nielsen April 2013

function C = fvcurtain_vec(C)

% default options
if ~isfield(C,'v_multi'), C.v_multi = 100; end           % 1 m/s or Kg/m/s etc etc = 100 pixels on screen
if ~isfield(C,'v_shape_head'), C.v_shape_head = [0.15 0.30 1]; end  % [width head, legth head, logical (true if frac of arrow length, false if abs values)]
if ~isfield(C,'v_shape_tail'), C.v_shape_tail = [0 1]; end % [width of stem, logical (true if frac of arrow length, false if abs value)];
if ~isfield(C,'v_color'), C.v_color = 'const'; end
if ~isfield(C,'v_facecolor'), C.v_facecolor = 'k'; end
if ~isfield(C,'v_edgecolor'), C.v_edgecolor = C.v_facecolor; end

% check
if ~C.chainage
    error('curtain vectors are only support when plotting depth against chainage')
end

% has fvcurtain_vec already been called ?
if ~isfield(C,'v_p')
    new = true;
    if ~isfield(C,'p')
        error('fvcurtain must be called prior to fvcurtain_vec')
    end
    dasp = get(C.h,'DataAspectRatio');
    C.dasp = dasp(3) / dasp(1);
else
    new = false;
end

% is fv_get_curtain extracting the velocity components already?
if new
    variables_old = C.fv_get_curtain.variables;
    variables_new = cat(1,variables_old,{'V_x';'V_y';'W'});
    variables_new = unique(variables_new);
    % -- does output for 'W' exist
    try
        tmp = netcdf.inqVarID(C.fv_get_curtain.nci,'W');
    catch
        display('W (vertical velocity component) output does not exist')
        display('Vertical component of velocity not included in vectors')
        variables_new = setxor(variables_new,{'W'});
    end
    if length(variables_old) ~= length(variables_new)
        nci = C.fv_get_curtain.nci;
        geofil = C.fv_get_curtain.geofil;
        pline = C.fv_get_curtain.pline;
        it = C.fv_get_curtain.it;
        % now fv_get_curtain will extract the variables for both fvcurtain and fvcurtain_vec when fvcurtain is called
        C = rmfield(C,'fv_get_curtain');
        C = fv_get_curtain(C,nci,geofil,pline,it,'variables',variables_new,'smooth',false,'chainage',C.chainage,'spherical',C.spherical,'data',C.data);
    end
end

% velocity components tangential to patch faces
tang = dot([C.V_x C.V_y],C.utang,2);
v_x = -tang .* C.utang(:,1);
% v_y = tang .* C.utang(:,2);
v_y = zeros(length(v_x),1);
if isfield(C,'W')
    v_z = C.W;
else
    v_z = zeros(length(v_x),1);
end

% verticees making patch objects for vectors;
% [C.v_pvx,C.v_pvy] = arrow2(v_xdat(S.v_i(S.v_j)),v_ydat(S.v_i(S.v_j)),S.v_x(S.v_j),S.v_y(S.v_j),'scale',S.v_scale,'shape_head',S.v_shape_head,'shape_tail',S.v_shape_tail,'shift',S.v_shift);

[C.v_pvx,C.v_pvy,C.v_pvz] = arrow3(v_x,v_y,v_z,C.face_centre(:,1),C.face_centre(:,2),C.face_centre(:,3),'shift',true,'scale',100,'shape',[0 0.2 0.35],'view','side','dasp',C.dasp); % 'scale',S.v_scale,'shape',S.v_shape,

C.v_pvy = -ones(size(C.v_pvy)); % if 0 then interers with patches

% create / update patch object
if new
    C.v_p = patch('XData',C.v_pvx,'YData',C.v_pvy,'ZData',C.v_pvz,'FaceColor',C.v_facecolor,'EdgeColor',C.v_edgecolor); % ,'FaceColor',C.v_facecolor,'EdgeColor',C.v_edgecolor,'parent',C.h
else
    set(C.v_p,'XData',C.v_pvx,'YData',C.v_pvy,'ZData',C.v_pvz);
end
